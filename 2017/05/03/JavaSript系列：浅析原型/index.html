<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, 前端, 技术, JavaScript, Nodejs,  Vuejs"><title>JavaSript系列：浅析原型 - 石沉大海 - baixiaoji的个人博客</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/baixiaoji"><span>Github</span></a></li><li><a href="/about/"><span>about</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">JavaSript系列：浅析原型</h1><ul class="meta"><li><i class="icon icon-author"></i>白小霁</li><li><i class="icon icon-clock"></i>11 Minutes</li><li><i class="icon icon-calendar"></i>May 3, 2017</li></ul></div></div><div class="article-content" style="max-width:800px"><h2 id="为什么要有原型对象"><a href="#为什么要有原型对象" class="headerlink" title="为什么要有原型对象"></a>为什么要有原型对象</h2><p>看到了阮老师的<a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank" rel="external">Javascript继承机制的设计思想</a>，明白了当初设计原型对象的历史原因：</p>
<ol>
<li>为了降低JavaScript的学习难度，所以不引入<code>类（class）</code>的概念</li>
<li>构造函数使用<code>new</code>运算符实例化对象后，并不能共享属性和方法，这一点不利于之后的继承<br>大概基于以上两点，Brendan Eich决定给构造函数设置一个<code>prototype</code>属性。</li>
</ol>
<h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><p>每一个构造函数都有一个<code>prototype</code>的属性，这个属性指向的一个对象，而这个对象就是原型对象。对于每一个实例化的对象而言，可以通过<code>__proto__</code>属性访问到其构造函数的<code>prototype</code>对象。按自己理解来说：每一个<code>Function</code>都有一个<code>prototype</code>属性，而该属性指向的就是原型对象，而原型对象上的作为一个公共区域，实例化的对象就可以访问到其构造函数的原型上的属性和方法。</p>
<h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">"baiji"</span>,<span class="number">10</span>)</div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Person(<span class="string">"baixiaoji"</span>,<span class="number">20</span>)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( baiji.sayName === baixiaoji.sayName )  <span class="comment">//logs false</span></div></pre></td></tr></table></figure>
<p>如果按照上述的代码，每一次实例化对象的时候，都要创建一个sayName的函数，如果要构造1000个Person的实例，那么内存一定会吃紧，所以<code>prototype</code>属性就可以将构造函数的公共的属性和方法都放上去。改写上述的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">"baiji"</span>,<span class="number">10</span>)</div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Person(<span class="string">"baixiaoji"</span>,<span class="number">20</span>)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( p1.sayName === p2.sayName )  <span class="comment">//logs true</span></div><div class="line"></div><div class="line"><span class="comment">// ES 6  </span></div><div class="line"><span class="comment">// 其中的class是一个语法糖 通过bable转化后和上述代码大概一致</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">    <span class="comment">// constructor 就是构造函数</span></div><div class="line">    <span class="keyword">constructor</span>(name,age)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name</div><div class="line">        <span class="keyword">this</span>.age = age  </div><div class="line">    &#125;</div><div class="line">    sayName()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将公共的方法抽取出来，挂在<code>prototype</code>上，可以供实例化的对象调用公共方法。</p>
<h3 id="文字说明"><a href="#文字说明" class="headerlink" title="文字说明"></a>文字说明</h3><p><code>Person</code>是一个构造函数，通过<code>new</code>可以构造出<code>Person</code>的一个实例对象（<code>p1、p2</code>），每一个对象都会有一个<code>__proto__</code>的属性指向构造函数的原型对象（<code>Person.prototype</code>）。每一个函数都会一个<code>prototype</code>的方法，指向一个对象；而每一个原型对象（<code>Person.prototype</code>）都有一个<code>constructor</code>指向这个函数本身（<code>Person()</code>）。</p>
<h3 id="大概关系如下图："><a href="#大概关系如下图：" class="headerlink" title="大概关系如下图："></a>大概关系如下图：</h3><p><img src="http://upload-images.jianshu.io/upload_images/599584-2fc7dad23d112791.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="来自简书"></p>
<p>这也就可以解释了，为什么每一个对象上都有一个<code>toString</code>的方法，见下图：<br><img src="http://upload-images.jianshu.io/upload_images/599584-da97dde356289ade.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="来自简书"><br>这样指向一层又一层的原型对象（会有终止），就是JavaScript的原型链，而我们可以基于原型链的特性，实现之后的<code>继承</code>。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 构建一个工人的类  继承原来人的特性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Worker</span>(<span class="params">name,age,workYear</span>)</span>&#123;</div><div class="line">    Person.call(<span class="keyword">this</span>,name,age)</div><div class="line">    <span class="keyword">this</span>.workYear = workYear</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">inherit(Person,Worker)</div><div class="line">Work.prototype.sayWork = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.work)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 构造一个函数来控制原型对象</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">superType, subType</span>)</span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">        Object.create  创建一个拥有指定原型和若干指定属性的对象  有兼容问题 </div><div class="line">        这个实现的好处：防止对子类的原型对象修改的时候，修改到了父类的原型对象上</div><div class="line">    */</div><div class="line">    <span class="keyword">let</span> __prototype = <span class="built_in">Object</span>.create(superType.prototype)</div><div class="line"></div><div class="line">    __prototype.constructor = subType </div><div class="line"></div><div class="line">    subType.prototype = __prototype</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Work(<span class="string">"baiji"</span>,<span class="number">10</span>,<span class="string">"学生"</span>)</div></pre></td></tr></table></figure>
<p>其实JavaScript中的继承是通过<code>原型链</code>的方式，实现了继承父类的方法和属性。由此，就是原型拓展的全部，知道了上面这些知识点，我们就可以去根据<strong>面向对象的方式</strong>去封装一些组件。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>每一个构造函数都有一个<code>prototype</code>属性，指向其原型对象，一般将公共的方法和属性挂在上面</li>
<li>由new运算符实例化的对象，通过<code>__proto__</code>属性访问其构造函数的原型对象</li>
<li>JavaScript通过<code>原型链</code>的方式实现继承</li>
</ol>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">11</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">15</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/总结/">总结</a><span class="category-list-count">12</span></li></ul></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cj28y0t48000c1wrhqwbgdfpb" data-title="JavaSript系列：浅析原型" data-url="http://yoursite.com/2017/05/03/JavaSript系列：浅析原型/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2017/04/29/浅析Promise/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/baixiaoji" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://www.douban.com/people/baixiaoji/" title="douban" target="_blank"><i class="icon icon-douban"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2017 石沉大海 - baixiaoji的个人博客<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>