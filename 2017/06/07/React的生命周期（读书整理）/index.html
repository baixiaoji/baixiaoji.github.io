<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, 前端, 技术, JavaScript, Nodejs,  Vuejs"><title>React的生命周期（读书整理） - 石沉大海 - baixiaoji的个人博客</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/baixiaoji"><span>Github</span></a></li><li><a href="/about/"><span>about</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">React的生命周期（读书整理）</h1><ul class="meta"><li><i class="icon icon-author"></i>白小霁</li><li><i class="icon icon-clock"></i>5 Minutes</li><li><i class="icon icon-calendar"></i>June 7, 2017</li></ul></div></div><div class="article-content" style="max-width:800px"><p>即使最近还是有点拖延，可还是再看一些关于React的东西。看到React组件的生命周期的时候，让我想到了Vue同样也有生命周期，即使两个框架在意义上有些不同，但是同样是一个东西从创建到消亡，类比到</p>
<p>React的组件定义了以下三个过程：</p>
<ol>
<li>Mouting(装载过程)：是在组件实例在创建时和插入DOM时调用的。</li>
<li>Update(更新过程)：当组件的<code>props</code>和<code>state</code>发生改变时，重新渲染页面是调用的。</li>
<li>Unmounting(卸载过程)：组件从DOM中移动时调用的。</li>
</ol>
<p>说了这些可能对于没有接触过React的人还是蛮陌生的，还是直接说每一个跟过程中有哪些方法可以调用。</p>
<h2 id="Mounting"><a href="#Mounting" class="headerlink" title="Mounting"></a>Mounting</h2><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><a href="https://facebook.github.io/react/docs/react-component.html#constructor" target="_blank" rel="external">constructor</a></h3><p>这个方法主要是为组件初始化<code>state</code>和绑定函数的<code>this</code>环境用的。</p>
<h3 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a><a href="https://facebook.github.io/react/docs/react-component.html#componentwillmount" target="_blank" rel="external">componentWillMount</a></h3><p>这个方法是在<code>render()</code>之前调用的，在这个函数当中不能对组件的<code>state</code>进行设置（就是<code>this.setState</code>），因为这时候即使修改了状态也不会触发，因为一切都太晚了，所以想在这个方法做的事情都可以提到<code>constructor</code>里面。</p>
<blockquote>
<p>This is the only lifecycle hook called on server rendering. Generally, we recommend using the constructor() instead.</p>
</blockquote>
<h3 id="render"><a href="#render" class="headerlink" title="render"></a><a href="https://facebook.github.io/react/docs/react-component.html#render" target="_blank" rel="external">render</a></h3><p>这是一个最重要的函数，每一个组件这是一个必须要有的函数。当这个函数被调用的时候，他会根据<code>props</code>和<code>state</code>的值返回一个React的组件，这个组件可以是原生的DOm组件也可以是你自己定义的组件；当然你也可以返回<code>null</code>和<code>false</code>，这样告诉React这次组件并没有什么东西去渲染。<br><code>render</code>函数是一个纯函数，所以在这个函数中不用修改组件的状态 </p>
<h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a><a href="https://facebook.github.io/react/docs/react-component.html#componentdidmount" target="_blank" rel="external">componentDidMount</a></h3><p>该函数并不是<code>render</code>运行完就立刻执行的，而是组件已经装载（Mounted）在DOM的时候，在这里就可以从远程加载数据，也可以发起网络请求（如AJAX）。这里<code>this.setState</code>是会触发重绘（re-rendering）。</p>
<h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><h3 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a><a href="https://facebook.github.io/react/docs/react-component.html#componentwillreceiveprops" target="_blank" rel="external">componentWillReceiveProps</a></h3><p>在父组件的render函数调用的时候，不论父组件传递给子组件的<code>props</code>值有没有发生变化，都会触发子组件的<code>componentWillReceiveProps</code>的方法。而且通过<code>this.setState</code>方法并不会调用该函数。</p>
<h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a><a href="https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate" target="_blank" rel="external">shouldComponentUpdate</a></h3><p>这个函数在整个组件的生命周期中也是尤为重要。<strong>因为这个函数决定一个组件什么时候不需要渲染。</strong>该函数的会接受新的<code>props</code>值和<code>state</code>值，而触发，默认返回是<code>true</code>值，告诉React继续渲染该组件，如果返回<code>flase</code>值则是终止后面的渲染。<br>其实根据上述解释并不会认为这是一个重要的函数！其实React主要火的原因是，会有对每一次的DOM渲染有一个<code>diff</code>算法，找出不同的节点信息再去渲染那一个节点，而这一个函数就是为了提高整体性能的作用。</p>
<h3 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a><a href="https://facebook.github.io/react/docs/react-component.html#componentwillupdate" target="_blank" rel="external">componentWillUpdate</a></h3><p>这个函数当中不能调用<code>this.setState</code>方法，如果你想更新状态让prop改变的话，还是使用<code>componentWillReceiveProps</code>函数。<strong>该函数不会在最初的render函数中调用。</strong></p>
<h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a><a href="https://facebook.github.io/react/docs/react-component.html#componentdidupdate" target="_blank" rel="external">componentDidUpdate</a></h3><p>这里可以操作DOM树了，因为组件已经完成了更新。这里也可以进行网络请求，也可以比较本次和上一次的<code>prop</code>值。<strong>该函数不会在最初的render函数中调用。</strong></p>
<h2 id="Unmounting"><a href="#Unmounting" class="headerlink" title="Unmounting"></a>Unmounting</h2><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a><a href="https://facebook.github.io/react/docs/react-component.html#componentwillunmount" target="_blank" rel="external">componentWillUnmount</a></h3><p>当React组件从DOM树上移除的时候调用。该函数的工作主要是和<code>componentDidMount</code>有关。</p>
<p>以上就是对React生命周期函数的稍许介绍，有疑问或理解偏颇的地方欢迎指出。</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/看书/">看书</a><span class="tag-list-count">1</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">25</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/总结/">总结</a><span class="category-list-count">22</span></li></ul></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cj3zjq8xy000dc8rhtrvknn26" data-title="React的生命周期（读书整理）" data-url="http://yoursite.com/2017/06/07/React的生命周期（读书整理）/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2017/06/08/你不知道的CSS系列/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2017/06/04/浅析jQuery源码之整体架构/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/baixiaoji" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://www.douban.com/people/baixiaoji/" title="douban" target="_blank"><i class="icon icon-douban"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2017 石沉大海 - baixiaoji的个人博客<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>