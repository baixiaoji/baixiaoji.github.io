<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, 前端, 技术, JavaScript, Nodejs,  Vuejs"><title>Property-getters-and-setters（译） - 石沉大海 - baixiaoji的个人博客</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/baixiaoji"><span>Github</span></a></li><li><a href="/about/"><span>about</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">Property-getters-and-setters（译）</h1><ul class="meta"><li><i class="icon icon-author"></i>白小霁</li><li><i class="icon icon-clock"></i>18 Minutes</li><li><i class="icon icon-calendar"></i>June 24, 2017</li></ul></div></div><div class="article-content" style="max-width:800px"><p>译者：@baixiaoji <a href="http://javascript.info/property-accessors#smarter-getters-setters" target="_blank" rel="external">原文</a></p>
<h1 id="属性的getters和setters"><a href="#属性的getters和setters" class="headerlink" title="属性的getters和setters"></a>属性的<code>getters</code>和<code>setters</code></h1><p>这是两种属不同类型的属性。</p>
<p>第一种就是数据的属性。我们已经知道他们是怎样运作的了。实际上，到目前为止我们用过的所有属性都是数据属性。</p>
<p>第二种的属性是有些不同的地方。他是访问器属性（accessor properties）。根本上，他们有设置和获取值的功能，但是从外部代码来看其实和寻常的属性没什么不同。</p>
<h2 id="Getters-and-setters"><a href="#Getters-and-setters" class="headerlink" title="Getters and setters"></a><a href="http://javascript.info/property-accessors#getters-and-setters" target="_blank" rel="external">Getters and setters</a></h2><p>访问器属性在代码中的表现形式就是<code>getter</code>和<code>setter</code>这两个方法。在一个字面量声明的对象，这两个方法的是用<code>get</code>和<code>set</code>表示的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  get propName() &#123;</div><div class="line">    <span class="comment">// getter, the code executed on getting obj.propName</span></div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  set propName(value) &#123;</div><div class="line">    <span class="comment">// setter, the code executed on setting obj.propName = value</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在读取<code>obj.propName</code>值的时候，<code>getters</code>运行了，而给<code>obj.propName</code>赋值的时候，<code>setter</code>运行了。<br>举个例子，现在我们有一个<code>user</code>的对象，有<code>name</code>和<code>surname</code>属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> user = &#123;</div><div class="line">  <span class="attr">name</span> : <span class="string">"John"</span>,</div><div class="line">  <span class="attr">surname</span>:　<span class="string">"Smith"</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>现在我们希望有一个<code>fullName</code>属性，其返回的值应该是「John Smith」。当然，我们不想复制粘贴现有的信息，所以我们可以将其作为一个访问器。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> user =　&#123;</div><div class="line">  <span class="attr">name</span> : <span class="string">"John"</span>,</div><div class="line">  <span class="attr">surname</span>:　<span class="string">"Smith"</span>,</div><div class="line">  get fullName()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.surname&#125;</span>`</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">alert(user.fullname)  <span class="comment">// John Smith</span></div></pre></td></tr></table></figure></p>
<p>从调用的角度来看，一个访问器属性和平常的属性很像。这就是访问器属性的理念。我们不会把<code>user.fullName</code>叫做一个函数，我们将看作一个平常的属性：<strong>getter</strong>在该场景背后默默运行。</p>
<p>目前为止，<code>fullName</code>只有一个<strong>getter</strong>。如果我们想去将其赋值时，就像这样<code>user.fullName=</code>，将会有一个报错。<br>我们通过给<code>user.fullName</code>添加一个<strong>setter</strong>来修复这个错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> user =　&#123;</div><div class="line">  <span class="attr">name</span> : <span class="string">"John"</span>,</div><div class="line">  <span class="attr">surname</span>:　<span class="string">"Smith"</span>,</div><div class="line">  get fullName()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.surname&#125;</span>`</span>;</div><div class="line">  &#125;,</div><div class="line">  </div><div class="line">  set fullName(value)&#123;</div><div class="line">    [<span class="keyword">this</span>.name, <span class="keyword">this</span>.surname] = value.split(<span class="string">" "</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">user.fullName = <span class="string">"Alice Cooper"</span></div><div class="line"></div><div class="line">alert(user.name) <span class="comment">// Alice</span></div><div class="line">alert(usrer.surname)  <span class="comment">// Cooper</span></div></pre></td></tr></table></figure></p>
<p>现在我们有一个「虚拟」属性，是一个可读可写的属性，可实际上不存在的属性。</p>
<blockquote>
<p><strong>Accessor properties are only accessible with get/set</strong><br>一个属性可以是数据属性，也可以是一个访问器属性，但不能同时是这两种属性的结合。<br>一旦将一个属性定义为<code>get prop</code>或是<code>set prop</code>，这就是个访问器属性。这样一来，如果想要读这个属性就要有一个geeter，想要给该属性赋值就要有一个setter。<br>有时候，可能一个属性只有setter或只有getter。这种情况下，属性只能写或是只能读。</p>
</blockquote>
<h2 id="Accessor-descriptors（访问器描述符）"><a href="#Accessor-descriptors（访问器描述符）" class="headerlink" title="Accessor descriptors（访问器描述符）"></a><a href="http://javascript.info/property-accessors#accessor-descriptors" target="_blank" rel="external">Accessor descriptors</a>（访问器描述符）</h2><p>与数据属性相比较，访问器的描述符有点不同。</p>
<p>对访问器属性而言，没有<code>value</code>和<code>writable</code>，将这两个属性代替的是<code>get</code>和<code>set</code>方法。<br>那么一个访问器属性的描述符就有一下四种：</p>
<ul>
<li><strong><code>get</code> </strong>— 一个没有参数的方法，在读取该属性的时候运行</li>
<li><strong><code>set</code></strong> — 一个有一个参数的方法，在该属性赋值的时候运行</li>
<li><strong><code>enumerable</code></strong> — 和数据属性相同</li>
<li><strong><code>configurable</code></strong> — 和数据属性相同</li>
</ul>
<p>举个例子，通过<code>defineProperty</code>创建一个访问器属性<code>fullName</code>，同时设置<code>get</code>和<code>set</code>这两个描述符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> user = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"John"</span>,</div><div class="line">  <span class="attr">surname</span>: <span class="string">"Smith"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">'fullName'</span>, &#123;</div><div class="line">  get() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.surname&#125;</span>`</span>;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  set(value) &#123;</div><div class="line">    [<span class="keyword">this</span>.name, <span class="keyword">this</span>.surname] = value.split(<span class="string">" "</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">alert(user.fullName); <span class="comment">// John Smith</span></div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> user) alert(key);</div></pre></td></tr></table></figure>
<p><strong>再次提醒</strong>，一个属性要么设置为访问器属性要么设置为数据属性，不能是这两种的结合。</p>
<p>如果我们尝试同时应用<code>get</code>和<code>value</code>在同一个描述器中，将会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Error: Invalid property descriptor.</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'prop'</span>, &#123;</div><div class="line">  get() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span></div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">value</span>: <span class="number">2</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="Smarter-getters-setters"><a href="#Smarter-getters-setters" class="headerlink" title="Smarter getters/setters"></a><a href="http://javascript.info/property-accessors#smarter-getters-setters" target="_blank" rel="external">Smarter getters/setters</a></h2><p>Getters/setters 可以作为真实属性的容器，已获得对其更多的控制。</p>
<p>举个例子，我们想给<code>user</code>禁止设置过短的<code>name</code>属性，我们可以将<code>name</code>属性存储在一个特殊的属性<code>_name</code>。并且在setter中过滤分配：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> user = &#123;</div><div class="line">  get name() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  set name(value) &#123;</div><div class="line">    <span class="keyword">if</span> (value.length &lt; <span class="number">4</span>) &#123;</div><div class="line">      alert(<span class="string">"Name is too short, need at least 4 characters"</span>);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>._name = value;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">user.name = <span class="string">"Pete"</span>;</div><div class="line">alert(user.name); <span class="comment">// Pete</span></div><div class="line"></div><div class="line">user.name = <span class="string">""</span>; <span class="comment">// Name is too short...</span></div></pre></td></tr></table></figure>
<p>严格来说，外部的代码可以直接通过<code>user._name</code>的形式来访问<code>name</code>。但这里有一个尝试就是：一个属性名由下划线（<code>_</code>）开始，则该属性是内部的，不容许在对象进行操作。</p>
<h2 id="Using-for-compatibility"><a href="#Using-for-compatibility" class="headerlink" title="Using for compatibility"></a><a href="http://javascript.info/property-accessors#using-for-compatibility" target="_blank" rel="external">Using for compatibility</a></h2><p>在getters和setters之后有一个好主意：它允许控制一个正常的数据属性并且可以随时进行调整。</p>
<p>举个例子：我们给<code>user</code>对象设置两个数据属性分别是<code>name</code>和<code>age</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> User(<span class="string">"John"</span>, <span class="number">25</span>);</div><div class="line"></div><div class="line">alert( john.age ); <span class="comment">// 25</span></div></pre></td></tr></table></figure>
<p>不久过后，有了些变化。我们决定将<code>age</code>替换为<code>birthday</code>，因为这样更加便利和准确：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, birthday</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.birthday = birthday;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> User(<span class="string">"John"</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1992</span>, <span class="number">6</span>, <span class="number">1</span>));</div></pre></td></tr></table></figure>
<p>现在还要使用<code>age</code>属性的旧代码怎么办？</p>
<p>我们找到所有的地方并修好它们，但如果代码是别人写的那就要费点时间。除此之外，对于<code>user</code>而言存在<code>age</code>是一件好事吗？在一些情境下，这就是我们想要的。</p>
<p>给<code>age</code>增加一个<code>getter</code>来减缓这个问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, birthday</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.birthday = birthday;</div><div class="line"></div><div class="line">  <span class="comment">// age is calculated from the current date and birthday</span></div><div class="line">  <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">"age"</span>, &#123;</div><div class="line">    get() &#123;</div><div class="line">      <span class="keyword">let</span> todayYear = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">      <span class="keyword">return</span> todayYear - <span class="keyword">this</span>.birthday.getFullYear();</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> User(<span class="string">"John"</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1992</span>, <span class="number">6</span>, <span class="number">1</span>));</div><div class="line"></div><div class="line">alert( john.birthday ); <span class="comment">// birthday is available</span></div><div class="line">alert( john.age );      <span class="comment">// ...as well as the age</span></div></pre></td></tr></table></figure>
<p>现在旧代码同样可以工作了，我们还额外获得了一个不错的属性。</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">15</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">27</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/总结/">总结</a><span class="category-list-count">23</span></li></ul></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cj6p4tbmx000cn8rhsnna86kt" data-title="Property-getters-and-setters（译）" data-url="http://yoursite.com/2017/06/24/Property-getters-and-setters（译）/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2017/08/23/React-Units-Test/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2017/06/16/Property-flags-and-descriptors（译）/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/baixiaoji" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://www.douban.com/people/baixiaoji/" title="douban" target="_blank"><i class="icon icon-douban"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2017 石沉大海 - baixiaoji的个人博客<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>